var exec = require('child_process').exec;
    fs = require('fs');
    http = require('http');
    os = require('os');
    path = require('path');
    url = require('url');
    util = require('util');

/* 
find takes as input two buffers. If the data in subBuffer is duplicated in sourceBuffer, 
then the index of the first character of the first occurence of the data is returned.
If the data is not duplicated, -1 is returned
This function is similar to the search() method for strings
*/
find = function (sourceBuffer, subBuffer) {
    //If the subbuffer is longer, it can't be a subbuffer, return -1.
    if (subBuffer.length>sourceBuffer.length) {
        return -1;
    } else {
        //If the subbuffer isn't longer, then check every possible slice from sourceBuffer
        //  which is the same length at subbuffer and see if they match
        for(var srcIndex=0;srcIndex<sourceBuffer.length-subBuffer.length+1;srcIndex++) {
            var slicedBuffer = sourceBuffer.slice(srcIndex,srcIndex+subBuffer.length);
            if (isMatch(slicedBuffer,subBuffer)) {
                return srcIndex;
            }
        }
        return -1;
    }
};
exports.find = find;

/*
findAfter is like find, except it begins searching the sourceBuffer at startIndex, instead of at the beginning
*/
findAfter = function (sourceBuffer, subBuffer, startIndex) {
    if (startIndex<sourceBuffer.length){
        if (startIndex>=0) {
            var foundIndex = find(sourceBuffer.slice(startIndex),subBuffer);
            if (foundIndex == -1) {
                return -1;
            } else {
                return foundIndex + startIndex;
            }
        }
    } else {
        return -1;
    }
};
exports.findAfter = findAfter;

/*
isMatch returns true if the two input buffers contain the same data
isMatch returns false otherwise
*/
isMatch = function (bfr1,bfr2) {
    //Buffers of different sizes won't match
    if (bfr1.length != bfr2.length) {
        return false;
    } else {
        //If one byte is different, return false
        for (var i=0;i<bfr1.length;i++) {
            if (bfr1[i]!=bfr2[i]) {
                return false;
            }
        }
        //If no bytes were different, return true
        return true;
    }
};
exports.isMatch = isMatch;

/*
join takes an array of Buffers and copies them into a single new Buffer
join returns a Buffer of length 0 if given an empty array
*/
join = function (bufferArray) {
    //If given an empty array as input, return a Buffer of length 0
    if (bufferArray.length==0) {
        return new Buffer(0);
    } else {
        //Calculate the length of the new Buffer by summing up the length of all the Buffers
        //   in the input array
        var totalLength = 0;
        for (var i = 0; i<bufferArray.length; i++) {
            totalLength = totalLength + bufferArray[i].length;
        }
        //Create the buffer to copy into
        var joinedBuffer = new Buffer(totalLength);
        //For keeping track of where we have copied to
        totalLength=0;
        //Copy every Buffer in bufferArray into the new Buffer
        for (var i = 0; i<bufferArray.length; i++) {
            bufferArray[i].copy(joinedBuffer,totalLength);
            totalLength = totalLength + bufferArray[i].length;
        }
        //And return the joined Buffer
        return joinedBuffer;
    }
};
exports.join = join;