/*
Author: Mitchell Ludwig

TODO: Make urlDecode translate percent-encoded data
*/
var bops = require('bufferOps');
var url = require('url');

parseURLEncoded = function(requestURL) {
    /* To break down the parsing:
       First, requestURL = "/dir1/page.js?foo=1&bar=2"
       Then,  url.parse(requestURL,true).search = "?foo=1&bar=2"
    */
    var urlSearch = url.parse(requestURL,true).search;
    // If there are URL encoded parameters
    if (urlSearch.length > 0) {
        /*
           url.parse(requestURL,true).search.slice(1) = "foo=1&bar=2"
           url.parse(requestURL,true).search.slice(1).split("&") = ["foo=1","bar=2"]
        */
        var urlSliceSplit = urlSearch.slice(1).split("&");
        var objectData = []; //Holds the data of each parameter, objectData["foo"]=1
        var singleValue = []; //Holds the data of one parameter, singleValue[0]="foo", singleValue[1]="1"
        //For every parameter
        for (var d in urlSliceSplit) {
            //Fill in singleValue
            singleValue = urlSliceSplit[d].split("=");
            //If there isn't exactly one '=' character
            if (singleValue.length != 2) {
                throw "URL Parsing error, invalid pair of: " + urlSliceSplit[d];
            } else {
                //Set objectData[parameter]=data
                objectData[urlDecode(singleValue[0])] = urlDecode(singleValue[1]);
            }
        }
        //Return all of the parameters
        return objectData;
    }
    //If no parameters exist, then return an empty array
    return [];
}
exports.parseURLEncoded = parseURLEncoded;

//TODO: Make urlDecode translate percent-encoded data
urlDecode = function(encodedURL) {
    var decodedURL = encodedURL.replace(/\+/g," ");
    var percentPosition = decodedURL.indexOf("%");
    while (percentPosition != -1){
        decodedURL = decodedURL.slice(0,percentPosition) + String.fromCharCode(parseInt(decodedURL.slice(percentPosition+1,percentPosition+3),16)) + decodedURL.slice(percentPosition+3);
        percentPosition = decodedURL.indexOf("%");
    }
    return decodedURL;
}
exports.urlDecode = urlDecode;


//This test buffer is simply the an example of the format of a multipart/formdata
// encoded Buffer
//exports.testBuffer = new Buffer("-----------------------------18621512727577\r\nContent-Disposition: form-data; name=\"MAX_FILE_SIZE\"\r\n\r\n500\r\n-----------------------------18621512727577\r\nContent-Disposition: form-data; name=\"uploadfile\"; filename=\"ciphertext.txt\"\r\nContent-Type: text/plain\r\n\r\nSIJYUMNVCAISPJLRBZEYQWYEULWMGWICJCIMTZEIMIBKNQWBRIVWYIGBWNBQQ\r\n-----------------------------18621512727577--\r\n");
/*
parseMultipartFormdata returns an array of Buffers containing the data for the form object
 with indicies being the names in the form.
One simply needs to pass in a full multipart/formdata encoded Buffer, and then you can 
access the data like so:
 x = require('uploadOps').parseMultipartFormdata(dataBuffer);
 console.log(x[MAX_FILE_SIZE].toString());
and on the console you will see the string '500'

This function is for extracting data from a multipart/formdata encoded Buffer,
 which looks like:
-----------------------------18621512727577
Content-Disposition: form-data; name="MAX_FILE_SIZE"

500
-----------------------------18621512727577
Content-Disposition: form-data; name="uploadfile"; filename="ciphertext.txt"
Content-Type: text/plain

SIJYUMNVCAISPJLRBZEYQWYEULWMGWICJCIMTZEIMIBKNQWBRIVWYIGBWNBQQ
-----------------------------18621512727577--

*/
parseMultipartFormdata = function (dataBuffer) {
        //Buffer representing the linefeed character
        var lineFeed = new Buffer(1);
        lineFeed[0]=10;
        //Buffer containing two CRLFs
        var crlfcrlfBuffer = new Buffer(4);
        crlfcrlfBuffer[0]=13;
        crlfcrlfBuffer[1]=10;
        crlfcrlfBuffer[2]=13;
        crlfcrlfBuffer[3]=10;
        
        //Buffer representing the 'name="' string
        var nameBuffer = new Buffer("name=\"");
        
        //Buffer representing the '"' string
        var quoteBuffer = new Buffer("\"");
        
        //Grab the first line, which separates all of the entries in the form data
        var sepEndIndex = bops.find(dataBuffer,lineFeed)-1;
        if (sepEndIndex==-1) {
            //If there is no linefeed, then there is malformed input.
            throw "Error in bufferOps.js.parseMultipartFormdata: Malformed Input, separator line not found";
        }
        
        var sepBuffer = dataBuffer.slice(0,sepEndIndex);
        /* The splitBuffer will split the dataBuffer into its individual parts, for example, from:
        <
        -----------------------------18621512727577
        Content-Disposition: form-data; name="MAX_FILE_SIZE"
        
        500
        -----------------------------18621512727577
        Content-Disposition: form-data; name="uploadfile"; filename="ciphertext.txt"
        Content-Type: text/plain
        
        SIJYUMNVCAISPJLRBZEYQWYEULWMGWICJCIMTZEIMIBKNQWBRIVWYIGBWNBQQ
        -----------------------------18621512727577--
        >
        
        into:
        
        [<
        >,<
        Content-Disposition: form-data; name="MAX_FILE_SIZE"
        
        500
        >,<
        Content-Disposition: form-data; name="uploadfile"; filename="ciphertext.txt"
        Content-Type: text/plain
        
        SIJYUMNVCAISPJLRBZEYQWYEULWMGWICJCIMTZEIMIBKNQWBRIVWYIGBWNBQQ
        >,<
        --
        >]
        */
        var splitBuffer = bops.split(dataBuffer,sepBuffer);
        var firstLine = "";
        var firstLineIndex = 0;
        var name = "";
        var nameIndex = 0;
        var nameEndIndex = 0;
        var objectData = [];
        //Find the buffer containing the requested data
        // NOTE: the splitBuffer array will look like
        // [<>,...,<-->]
        // this means that we don't need to check the first or last elements of the array
        for (var i = 1; i<splitBuffer.length-1; i++) {
            //Get the index of the carriage return at the end of the second line
            firstLineIndex = bops.findAfter(splitBuffer[i],lineFeed,2)-1;
            if (firstLineIndex==-1) {
                //If there is no new line, then there is malformed input.
                throw "Error in bufferOps.js.parseMultipartFormdata: Malformed Input, newline not found";
            }
            //Get the first line
            firstLine = splitBuffer[i].slice(2,firstLineIndex);
            //Find the 'name="' string
            nameIndex = bops.find(firstLine,nameBuffer);
            if (nameIndex == -1) {
                throw "Error in bufferOps.js.parseMultipartFormdata: Malformed Input, name field not found";
            }
            nameIndex += nameBuffer.length;
            //If 'name="' is found, find the trailing quote
            nameEndIndex = bops.findAfter(firstLine,quoteBuffer,nameIndex);
            if (nameIndex == -1) {
                throw "Error in bufferOps.js.parseMultipartFormdata: Malformed Input, name field error";
            }
            //Finally, get the name
            name = firstLine.slice(nameIndex,nameEndIndex).toString();
            
            //Find the two newlines in a row, they indicate the start of the data
            startIndex = bops.find(splitBuffer[i],crlfcrlfBuffer);
            if (startIndex==-1) {
                throw "Error in bufferOps.js.parseMultipartFormdata: Malformed Input";
            }
            startIndex += crlfcrlfBuffer.length;
            //Now the first byte of the data is at startIndex
            // and the splitBuffer[i] section ends at the end of the data, so now it's easy
            //Just put the rest into the array, minus the trailing carriage return line feed
            objectData[name] = splitBuffer[i].slice(startIndex,splitBuffer[i].length-2);
        }
        return objectData;
};
exports.parseMultipartFormdata = parseMultipartFormdata;